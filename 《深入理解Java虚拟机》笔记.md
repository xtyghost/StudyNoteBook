### Java虚拟机运行时数据区域

#### 程序计数器

线程私有,线程执行Java方法时,存储虚拟机正在执行的字节码指令的地址.线程执行Native方法时,值为空.

#### Java虚拟机栈

#### 本地方法栈

#### Java堆

+ 新生代
  + Eden (8)
  + From Survivor (1)
  + To Survivor (1)
+ 老年代

所有线程共享 

每个线程可以分配独立的缓冲区,称为本地线程分配缓冲(TLAB)

#### 方法区

+ 运行时常量池
+ 直接内存 (NIO使用Native方法直接分配的堆外内存)

所有线程共享,存储已被虚拟机加载的类信息,常量,静态变量,即时编译器编译后的代码等数据.

##### 运行时常量池

### Java对象

#### 对象创建

1. 先检查要创建对象的类是否已加载,如果没有,先加载类.
2. 为对象分配内存,内存规整时(垃圾收集器有压缩整理功能),采用指针碰撞方法,内存不规整时,采用空闲列表方法.
3. 将分配的内存初始化为零值
4. 将类的元数据信息,对象的哈希码,对象的GC分代年龄信息等存入对象头.
5. 初始化对象值

#### 对象的内存布局

##### 对象头

1. 对象自身运行时的数据: 哈希码,GC分代年龄,锁状态标志,等
2. 指向类元数据的指针
3. 如果是数组对象,存储数组长度

##### 实例数据

从父类继承的和自身的字段内容

##### 对齐填充

HotSpot VM要求对象大小必须是8字节的整数倍,当实例数据不足时,通过对齐填充来补全.

#### 对象的访问定位

+ 句柄访问
+ 直接指针访问

### 垃圾收集算法

#### 标记-清除

效率不高,容易产生内存碎片

#### 复制算法

将内存分为相等两块,当一块内存用完,将存活对象复制到另一块内存,将当前内存清掉.主要用来回收新生代.

#### 标记-整理

### 垃圾收集器

#### Serial收集器

单线程

#### ParNew收集器

Serial的多线程版

#### Parallel Scavenge收集器

多线程,吞吐量优先,可以设置自适应调节策略

#### Serial Old收集器

单线程,Serial的老年代版

#### Parallel Old收集器

多线程,Parallel Scavenge的老年代版

#### CMS收集器

Concurrent Mark Sweep

+ 优点 : 并发收集,低停顿
+ 缺点 : 占用CPU资源多,采用标记-清除算法,容易产生内存碎片,无法处理浮动垃圾(垃圾收集时用户线程产生的垃圾)

#### G1收集器

### 虚拟机监控工具

#### jps

```shell
jps [options] [hostid]
# 参数
-q # 只输出LVMID,省略主类的名称
-m # 输出虚拟机进程启动时传递给main()函数的参数
-l # 输出主类的全名称,如果运行的是jar包,输出jar路径
-v # 输出虚拟机进程启动时的JVM参数
```

#### jstat

```shell
jstat [option] 进程ID 间隔毫秒值 查询次数
```

#### JConsole

#### VisualVM

```shell
jvisualvm
```

### 虚拟机类加载机制

#### 类的生命周期

1. **加载 Loading**

   1. 通过全类名获取类的二进制字节流
   2. 将字节流中静态存储结构转化为方法区运行时数据结构
   3. 在内存中生成类的java.lang.Class对象,作为方法区各种数据的访问入口

2. **验证 Verification**

   1. 文件格式验证
   2. 元数据验证
   3. 字节码验证
   4. 符号引用验证

3. **准备 Preparation**

   为类变量分配内存并设置初始值(静态变量设置零值,静态常量设置具体值)

4. **解析 Resolution**

   将常量池内的符号引用替换为直接引用

5. **初始化 Initialization**

   执行` <clinit>() `方法,` <clinit>() `由编译器生成,其中包括类变量赋值和static{}代码块.子类在执行之前,父类的` <clinit>() `已经执行完毕.多个线程同时初始化一个类时,只会有一个线程执行,其他线程需要阻塞等待.

6. **使用 Using**

7. **卸载 Unloading**

### 虚拟机字节码执行引擎

#### 运行时栈帧结构

+ 局部变量表

  存放方法参数和局部变量,32位为一个Slot,long和dubbo占用两个slot

  非静态方法第0位索引slot为this

#### 基于栈的指令集

+ 优点 : 可移植,编译器实现简单
+ 缺点 : 执行速度慢

### Java内存模型与线程

#### 主内存与工作内存

所有变量都存储在主内存,每条线程有自己的工作内存,线程工作内存保存主内存的变量副本,线程对变量的操作在工作内存中执行.

#### Java与线程

##### 线程的实现

1. 使用内核线程实现(KLT)

   每个内核线程对应一个轻量级进程(LWP).缺点:每次调用需要在用户态和内核态切换.

2. 使用用户线程实现(UT)

   广义上,一个线程只要不是内核线程,就属于用户线程.狭义上,完全建立在用户空间的线程库上.优点:不需要切换到内核态.缺点:所有线程操作需要用户自己处理.

3. 使用用户线程加轻量级进程混合实现

#### Java中的线程安全

1. 不可变

   final修饰,String,基本类型包装类等

2. 绝对线程安全

3. 相对线程安全

   通过synchronized修饰

4. 线程兼容

   本身不安全,可以通过使用同步保证安全

5. 线程对立

#### 线程安全实现方法

1. 互斥同步

2. 非阻塞同步

   先进行操作,如果没有其他线程争用共享数据,操作成功.如果共享数据有争用,在采取补偿措施.

   CAS(Compare and Swap): CAS指令有三个操作数,V(变量的内存地址),A(旧的预期值),B(新值),CAS指令执行时,当且仅当V符合A时,处理器用B更新V,否则不更新,无论是否更新V,都会返回V的旧值.

3. 无同步方案

   + 可重入代码
   + 线程本地存储

#### 锁优化

1. 自旋锁与自适应自旋锁

   由于线程挂起和恢复都需要转入内核态,性能低,短时间内挂起恢复不值得,让请求锁线程自旋一段时间等待锁.自适应自旋锁,自动判断自旋次数.

2. 锁消除

   虚拟机即时编译器通过逃逸分析,判断锁内数据不是共享的,会把锁清楚.

3. 锁粗化

   虚拟机检测到连续的锁操作,会把锁扩大到整个操作范围

4. 轻量级锁

   代码进入同步块时,如果对象没有锁定,虚拟机会在当前线程栈帧中建立一个锁记录(Lock Record),存储锁对象的MarkWord的拷贝,然后虚拟机使用CAS操作尝试将对象的MarkWord更新为指向LockRecord的指针.如果更新成功了,这个线程就拥有了该对象的锁,并把对象MarkWord的锁标志为改为轻量级锁.如果更新失败,检查对象的MarkWord是否指向当前线程栈帧,如果指向,说明当前线程已经拥有这个对象的锁,直接进入同步块继续执行.否则,说明锁对象已经被其他线程抢占.如果有两条以上线程争用一个锁,就膨胀为重量级锁.

   如果没有竞争,轻量级锁使用CAS避免了使用互斥量的开销.如果存在锁竞争,除了互斥量开销外,还进行CAS,会比重量级锁更慢.

5. 偏向锁

   执行CAS操作成功后,持有偏向锁的线程以后进入这个锁的同步块不再进行同步操作.当另外一个线程尝试获取这个锁时,偏向模式结束.