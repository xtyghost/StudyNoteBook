### Java虚拟机运行时数据区域

#### 程序计数器

线程私有,线程执行Java方法时,存储虚拟机正在执行的字节码指令的地址.线程执行Native方法时,值为空.

#### Java虚拟机栈

#### 本地方法栈

#### Java堆

+ 新生代
  + Eden (8)
  + From Survivor (1)
  + To Survivor (1)
+ 老年代

所有线程共享 

每个线程可以分配独立的缓冲区,称为本地线程分配缓冲(TLAB)

#### 方法区

+ 运行时常量池
+ 直接内存 (NIO使用Native方法直接分配的堆外内存)

所有线程共享,存储已被虚拟机加载的类信息,常量,静态变量,即时编译器编译后的代码等数据.

##### 运行时常量池

### Java对象

#### 对象创建

1. 先检查要创建对象的类是否已加载,如果没有,先加载类.
2. 为对象分配内存,内存规整时(垃圾收集器有压缩整理功能),采用指针碰撞方法,内存不规整时,采用空闲列表方法.
3. 将分配的内存初始化为零值
4. 将类的元数据信息,对象的哈希码,对象的GC分代年龄信息等存入对象头.
5. 初始化对象值

#### 对象的内存布局

##### 对象头

1. 对象自身运行时的数据: 哈希码,GC分代年龄,锁状态标志,等
2. 指向类元数据的指针
3. 如果是数组对象,存储数组长度

##### 实例数据

从父类继承的和自身的字段内容

##### 对齐填充

HotSpot VM要求对象大小必须是8字节的整数倍,当实例数据不足时,通过对齐填充来补全.

#### 对象的访问定位

+ 句柄访问
+ 直接指针访问

### 垃圾收集算法

#### 标记-清除

效率不高,容易产生内存碎片

#### 复制算法

将内存分为相等两块,当一块内存用完,将存活对象复制到另一块内存,将当前内存清掉.主要用来回收新生代.

#### 标记-整理

### 垃圾收集器

#### Serial收集器

单线程

#### ParNew收集器

Serial的多线程版

#### Parallel Scavenge收集器

多线程,吞吐量优先,可以设置自适应调节策略

#### Serial Old收集器

单线程,Serial的老年代版

#### Parallel Old收集器

多线程,Parallel Scavenge的老年代版

#### CMS收集器

Concurrent Mark Sweep

+ 优点 : 并发收集,低停顿
+ 缺点 : 占用CPU资源多,采用标记-清除算法,容易产生内存碎片,无法处理浮动垃圾(垃圾收集时用户线程产生的垃圾)

#### G1收集器

### 虚拟机监控工具

#### jps

```shell
jps [options] [hostid]
# 参数
-q # 只输出LVMID,省略主类的名称
-m # 输出虚拟机进程启动时传递给main()函数的参数
-l # 输出主类的全名称,如果运行的是jar包,输出jar路径
-v # 输出虚拟机进程启动时的JVM参数
```

#### jstat

```shell
jstat [option] 进程ID 间隔毫秒值 查询次数
```

#### JConsole

#### VisualVM

```shell
jvisualvm
```

